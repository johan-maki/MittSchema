<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Enhanced Schedule Generation</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .console { background: #f0f0f0; padding: 15px; margin: 10px 0; border-radius: 5px; max-height: 400px; overflow-y: auto; }
        button { padding: 10px 20px; margin: 5px; cursor: pointer; }
        .success { color: green; }
        .error { color: red; }
        .info { color: blue; }
    </style>
</head>
<body>
    <h1>🧪 Enhanced Schedule Generation Test</h1>
    <p>This page tests the enhanced local schedule generation in isolation.</p>
    
    <button onclick="testGeneration()">🚀 Test Enhanced Generation</button>
    <button onclick="clearConsole()">🧹 Clear Console</button>
    
    <div id="console" class="console">
        <div class="info">Ready to test enhanced schedule generation...</div>
    </div>

    <script>
        function log(message, type = 'info') {
            const console = document.getElementById('console');
            const div = document.createElement('div');
            div.className = type;
            div.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            console.appendChild(div);
            console.scrollTop = console.scrollHeight;
        }

        function clearConsole() {
            document.getElementById('console').innerHTML = '<div class="info">Console cleared...</div>';
        }

        async function testGeneration() {
            log('🧪 Starting enhanced schedule generation test...', 'info');
            
            // Mock data
            const mockProfiles = [
                { id: '1', first_name: 'Anna', last_name: 'Andersson', role: 'Läkare' },
                { id: '2', first_name: 'Erik', last_name: 'Eriksson', role: 'Sjuksköterska' },
                { id: '3', first_name: 'Maria', last_name: 'Johansson', role: 'Undersköterska' },
                { id: '4', first_name: 'Carl', last_name: 'Carlsson', role: 'Läkare' },
                { id: '5', first_name: 'Sofia', last_name: 'Gustafsson', role: 'Sjuksköterska' },
                { id: '6', first_name: 'Lars', last_name: 'Larsson', role: 'Undersköterska' },
                { id: '7', first_name: 'Emma', last_name: 'Nilsson', role: 'Läkare' },
                { id: '8', first_name: 'Olof', last_name: 'Olsson', role: 'Sjuksköterska' }
            ];

            log(`👥 Using ${mockProfiles.length} mock employees`, 'info');

            // Two weeks starting from today
            const startDate = new Date();
            startDate.setDate(startDate.getDate() - startDate.getDay()); // Start of current week
            
            const endDate = new Date(startDate);
            endDate.setDate(endDate.getDate() + 13); // 14 days total

            log(`📅 Period: ${startDate.toDateString()} to ${endDate.toDateString()}`, 'info');

            // Simulate enhanced generation algorithm
            const shifts = [];
            const employeeWorkload = {};
            
            // Initialize workload tracking
            mockProfiles.forEach(profile => {
                employeeWorkload[profile.id] = {
                    name: `${profile.first_name} ${profile.last_name}`,
                    totalHours: 0,
                    shiftsCount: 0,
                    lastShiftDate: null,
                    consecutiveDays: 0,
                    weekendShifts: 0
                };
            });

            const shiftTypes = [
                { type: 'day', start: '08:00', end: '16:00', duration: 8 },
                { type: 'evening', start: '16:00', end: '00:00', duration: 8 },
                { type: 'night', start: '00:00', end: '08:00', duration: 8 }
            ];

            const totalDays = 14;
            const targetShiftsPerEmployee = Math.floor((totalDays * 2) / mockProfiles.length);
            
            log(`🎯 Target shifts per employee: ~${targetShiftsPerEmployee}`, 'info');

            // Generate shifts day by day
            const currentDay = new Date(startDate);
            
            for (let day = 0; day < totalDays; day++) {
                const dateStr = currentDay.toISOString().split('T')[0];
                const isWeekend = currentDay.getDay() === 0 || currentDay.getDay() === 6;
                
                log(`📆 Processing ${dateStr} (${isWeekend ? 'Weekend' : 'Weekday'})`, 'info');

                // Limit shifts per day (2-3 shifts)
                const dailyShifts = isWeekend ? shiftTypes.slice(0, 2) : shiftTypes.slice(0, 2);
                
                for (const shiftType of dailyShifts) {
                    // Find best employee (fairest distribution)
                    const availableEmployees = mockProfiles.filter(employee => {
                        const workload = employeeWorkload[employee.id];
                        
                        // Basic availability check
                        if (workload.lastShiftDate) {
                            const lastDate = new Date(workload.lastShiftDate);
                            const currentDate = new Date(dateStr);
                            const dayDiff = (currentDate.getTime() - lastDate.getTime()) / (1000 * 60 * 60 * 24);
                            
                            // No consecutive days if they've already worked 3 in a row
                            if (dayDiff === 1 && workload.consecutiveDays >= 3) {
                                return false;
                            }
                        }
                        return true;
                    });

                    if (availableEmployees.length === 0) {
                        log(`⚠️ No available employee for ${shiftType.type} shift on ${dateStr}`, 'error');
                        continue;
                    }

                    // Score employees (lower = better)
                    const scoredEmployees = availableEmployees.map(employee => {
                        const workload = employeeWorkload[employee.id];
                        let score = 0;

                        // Primary: how many shifts compared to target
                        const shiftDeficit = targetShiftsPerEmployee - workload.shiftsCount;
                        score -= shiftDeficit * 10;

                        // Secondary: total hours
                        score += workload.totalHours * 0.1;

                        // Weekend fairness
                        if (isWeekend) {
                            score += workload.weekendShifts * 2;
                        }

                        // Rest preference
                        if (workload.lastShiftDate) {
                            const lastDate = new Date(workload.lastShiftDate);
                            const currentDate = new Date(dateStr);
                            const daysSinceLastShift = (currentDate.getTime() - lastDate.getTime()) / (1000 * 60 * 60 * 24);
                            score -= daysSinceLastShift * 0.5;
                        } else {
                            score -= 5; // Strong preference for new employees
                        }

                        return { employee, score };
                    });

                    // Sort by score (lowest first)
                    scoredEmployees.sort((a, b) => a.score - b.score);
                    const bestEmployee = scoredEmployees[0].employee;

                    // Create shift
                    const shift = {
                        id: `shift_${shifts.length + 1}`,
                        date: dateStr,
                        type: shiftType.type,
                        employee_id: bestEmployee.id,
                        employee_name: `${bestEmployee.first_name} ${bestEmployee.last_name}`,
                        duration: shiftType.duration
                    };

                    shifts.push(shift);

                    // Update workload
                    const workload = employeeWorkload[bestEmployee.id];
                    workload.totalHours += shiftType.duration;
                    workload.shiftsCount++;
                    
                    const previousLastShiftDate = workload.lastShiftDate;
                    workload.lastShiftDate = dateStr;
                    
                    if (previousLastShiftDate) {
                        const lastDate = new Date(previousLastShiftDate);
                        const currentDate = new Date(dateStr);
                        const dayDiff = (currentDate.getTime() - lastDate.getTime()) / (1000 * 60 * 60 * 24);
                        
                        if (dayDiff === 1) {
                            workload.consecutiveDays++;
                        } else {
                            workload.consecutiveDays = 1;
                        }
                    } else {
                        workload.consecutiveDays = 1;
                    }

                    if (isWeekend) {
                        workload.weekendShifts++;
                    }

                    log(`✅ Assigned ${shiftType.type} shift to ${bestEmployee.first_name} ${bestEmployee.last_name}`, 'success');
                }

                currentDay.setDate(currentDay.getDate() + 1);
            }

            // Final results
            log(`🎉 Generated ${shifts.length} shifts successfully!`, 'success');
            log('📊 Final workload distribution:', 'info');
            
            Object.values(employeeWorkload).forEach(emp => {
                log(`  ${emp.name}: ${emp.shiftsCount} shifts (${emp.totalHours} hours)`, 'info');
            });

            // Check fairness
            const shiftCounts = Object.values(employeeWorkload).map(emp => emp.shiftsCount);
            const minShifts = Math.min(...shiftCounts);
            const maxShifts = Math.max(...shiftCounts);
            const difference = maxShifts - minShifts;
            
            if (difference <= 2) {
                log(`✅ Fair distribution achieved! Max difference: ${difference} shifts`, 'success');
            } else {
                log(`⚠️ Distribution could be improved. Max difference: ${difference} shifts`, 'error');
            }

            log('🏁 Enhanced generation test completed!', 'success');
        }
    </script>
</body>
</html>
