
import { useQuery } from "@tanstack/react-query";
import { useAuth } from "@/contexts/AuthContext";
im                return false;
              }
            }om "@/integrations/supabase/client";
import { Shift, ShiftType } from "@/types/shift";
import { format, addDays, startOfMonth, endOfMonth, isWithinInterval } from "date-fns";

export const useShiftData = (currentDate: Date, currentView: 'day' | 'week' | 'month') => {
  const { user } = useAuth();

  return useQuery({
    queryKey: ['shifts', currentDate, currentView],
    queryFn: async () => {
      if (!user) return [];
      
      let startDate, endDate;
      
      // Determine the date range based on the view
      if (currentView === 'day') {
        startDate = new Date(currentDate);
        startDate.setHours(0, 0, 0, 0); // Set to start of day
        endDate = new Date(currentDate);
        endDate.setHours(23, 59, 59, 999); // Set to end of day
      } else if (currentView === 'week') {
        // Start from Monday of the current week
        const dayOfWeek = currentDate.getDay();
        startDate = new Date(currentDate);
        startDate.setDate(currentDate.getDate() - (dayOfWeek === 0 ? 6 : dayOfWeek - 1));
        startDate.setHours(0, 0, 0, 0); // Set to start of day
        endDate = new Date(startDate);
        endDate.setDate(startDate.getDate() + 6); // End on Sunday
        endDate.setHours(23, 59, 59, 999); // Set to end of day
      } else { // month
        startDate = startOfMonth(currentDate);
        endDate = endOfMonth(currentDate);
        
        // ðŸ”§ CRITICAL FIX: Extend end date to capture night shifts that start on last day  
        // Problem: Night shifts starting 31/8 22:00 are filtered out by endDate 31/8 21:59:59.999Z
        // Solution: Extend to next day early morning to capture night shifts that cross month boundaries
        endDate = addDays(endDate, 1); // Add 1 day to include next day
        endDate.setHours(5, 59, 59, 999); // Capture night shifts until 06:00 next day (night shifts end at 06:00)
        
        // ðŸ” Debug logging for query range 
        console.log(`ðŸ“… EXTENDED MONTH QUERY: ${format(startDate, 'yyyy-MM-dd HH:mm:ss')} to ${format(endDate, 'yyyy-MM-dd HH:mm:ss')}`);
        console.log(`ðŸ” Query will capture shifts starting between ${startDate.toISOString()} and ${endDate.toISOString()}`);
      }
      
      // Format dates to ISO strings in UTC
      const startDateStr = startDate.toISOString();
      const endDateStr = endDate.toISOString();
      
      // Get shifts from Supabase
      const { data: shifts, error } = await supabase
        .from('shifts')
        .select(`
          *,
          profiles:employees!shifts_employee_id_fkey (
            first_name,
            last_name,
            experience_level
          )
        `)
        .gte('start_time', startDateStr)
        .lte('start_time', endDateStr)
        .order('start_time', { ascending: true });
      
      if (error) {
        console.error('Error fetching shifts:', error);
        return [];
      }
      
      console.log(`Retrieved ${shifts?.length || 0} shifts from Supabase`);
      
      // ðŸ” Quick verification for August boundary debugging  
      if (currentView === 'month' && shifts && shifts.length > 0) {
        const august31Shifts = shifts.filter(s => 
          s.start_time && s.start_time.includes('2025-08-31')
        );
        if (august31Shifts.length > 0) {
          console.log(`ðŸ—“ï¸ August 31 shifts retrieved:`, august31Shifts.map(s => ({
            start_time: s.start_time,
            shift_type: s.shift_type,
            employee_id: s.employee_id
          })));
        }
      }
      
      // Filter out shifts with invalid profile data and type-safe transform
      const validShifts: Shift[] = (shifts || [])
        .filter(shift => {
          // ðŸ”§ CRITICAL FIX: Only filter out shifts that don't belong to target month
          // BUT keep night shifts that START in target month even if they end in next month
          if (currentView === 'month') {
            const targetMonth = currentDate.getMonth() + 1; // 1-indexed month
            const targetYear = currentDate.getFullYear();
            const shiftStartTime = shift.start_time;
            
            if (shiftStartTime) {
              const [shiftYear, shiftMonth] = shiftStartTime.split('-').map(Number);
              
              // ðŸŒ™ KEEP night shifts that START in target month (even if they cross into next month)
              // Only filter out shifts that actually start in a different month/year
              if (shiftMonth !== targetMonth || shiftYear !== targetYear) {
                console.log(`ï¿½ Filtering out non-target month shift:`, {
                  id: shift.id,
                  start_time: shiftStartTime,
                  shift_month: shiftMonth,
                  target_month: targetMonth,
                  shift_year: shiftYear,
                  target_year: targetYear,
                  shift_type: shift.shift_type,
                  reason: 'Shift starts outside target month/year'
                });
                return false;
              }
              
              // âœ… KEEP ALL shifts that start in target month (including boundary night shifts)
              console.log(`âœ… Keeping target month shift:`, {
                id: shift.id,
                start_time: shiftStartTime,
                shift_type: shift.shift_type,
                reason: 'Shift starts in target month'
              });
            }
          }
          
          if (!shift.profiles || typeof shift.profiles !== 'object') {
            console.warn('Invalid profile data for shift:', shift.id);
            return false;
          }
          // Check if profiles has error property (SelectQueryError)
          if ('error' in shift.profiles && shift.profiles.error) {
            console.warn('Profile query error for shift:', shift.id, shift.profiles);
            return false;
          }
          // Ensure required profile fields exist
          return shift.profiles && 
                 typeof shift.profiles === 'object' &&
                 'first_name' in shift.profiles && 
                 'last_name' in shift.profiles &&
                 shift.profiles.first_name && 
                 shift.profiles.last_name;
        })
        .map(shift => {
          const profileData = shift.profiles as { first_name: string; last_name: string; experience_level?: number };
          return {
            ...shift,
            profiles: {
              first_name: profileData.first_name,
              last_name: profileData.last_name,
              hourly_rate: undefined, // Default since it doesn't exist in employees table
              experience_level: profileData.experience_level || 1 // Add experience_level with default
            }
          };
        });
      
      return validShifts;
    },
    enabled: !!user,
    staleTime: 0, // Force fresh data
    refetchOnWindowFocus: true
  });
};
